

结构体(struct)
	Golang中没有"类"的概念,Golang中的结构体和其他语言中的类有点相似.
	Golang中的结构体具有更高的扩展性和灵活性
	Golang中的技术数据类型可以表示一些事物的基本属性,但是想表达一个事物的全局或部分属性时,
	这时候再用单一的基本数据类型就无法满足需求了.
	Golang提供了一种自定义数据类型,可以封装多个基本数据类型,这种数据类型叫结构体(struct)


	自定义类型
		Go语言中可以使用type关键字来定义自定义类型

	类型别名
		类型别名规定: TypeAlias只是Type的别名,本质上TypeAlias是同一个类型

	结构体首字母可以大写也可以小写,大写表示这个结构体是公有的,在其他包里面可以使用,小写表示这个结构体是私有的,只有这个包才能使用.

	结构体实例化
		只有当结构体实例化时,才会真正地分配内存,也就是必须实例化后才能使用结构体的字段.
		结构体本身也是一种类型,可以像声明内置类型一样使用"var"关键字声明结构体类型.
		在Golang中支持对结构体指针直接使用,来访问结构体的成员.


	结构体方法和接收者
		1.值类型的接收者
			当方法用于值类型接收者是,Go语言会在代码运行时将接收者的值复制一份,在值类型接收者的方法中可以获取接收者的成员值;
			但修改操作知识针对副本,无法修改接收者变量本身

		2.指针类型的接收者
			指针类型的接收者由一个结构体指针组成,由于指针的特性,调用方法是修改接收者指针的任意成员时,在方法结束后,修改都是有效的.
			这种方法就十分近于其他语言中面向对象中的this或者self.

	给任意类型添加方法
		Go语言中,接收者的类型可以是任何类型,不仅仅是结构体,任何类型都可以拥有方法.
		非本地类型不能定义方法,不能给别的包的类型定义方法.

	结构体的匿名字段
		结构体允许其成员字段在声明时没有字段名而只有类型,这种欧诺个没有名字的字段就称为匿名字段.
		匿名字段默认采用类型名作为字段名,结构体要求字段名称必须唯一,因此一个结构体中同种类型的匿名字段只能有一个.

	嵌套结构体
		一个结构体中可以嵌套另一个结构体或结构体指针

	关于嵌套结构体的字段名冲突
		嵌套结构体内部可能存在相同的字段名,这时候为了避免歧义需要指定具体的内嵌结构体的字段.

	结构体的继承
		Go语言中使用结构体也可以实现其他编程语言中国的继承



Golang结构体与JSON
	Gol昂JSON序列化是指把结构体数据转化成JSON格式的字符串,Golang JSON的反序列化是指把JSON数据转化成Golang中的结构体对象
	Golang中的序列化和反序列化主要通过"encoding/json"包中的json.Marshal()和json.Unmarshal()方法实现
		结构体转JSON: json.Marshal()
		JSON装结构体: json.Unmarshal()

	结构体标签Tag
		Tag是结构体的元信息,可以在运行的时候通过反射机制读取出来.Tag在结构体字段的后方定义,由一堆反引号包裹起来.
		结构体tag由一个或多个键值对组成.键与值使用冒号分隔,值用双引号括起来.同一个结构体字段可以设置多个键值对tag,
		不同的键值对之间很实用空格分隔.

		注意事项:
			为结构体编写Tag时,必须严格遵守键值对的规则.
			结构体标签的解析代码的容错能力很差,一旦格式写错,编译和运行时都不会提示任何错误,通过反射也无法正确取值.
			例如:不要再key和value之间添加空格



Golang中的go mod及golang包详解
	Golang中的包可以分为三种: 
		1、系统内置包
			Golang语言提供的内置包,引入后可以直接使用,如fmt、strconv、strings、sort、errors、time、encoding/json、os、io等.

		2、自定义包
			开发者自己写的包

		3、第三方包
			属于自定义的一种,需要下载安装到本地后才可以使用


	go mod:
		在Golang1.11版本之前如果要自定义包的话必须把项目放在GOPATH目录.Go1.11版本之后无需手动配置环境变量,使用go mod管理项目,
		也不需要非得把项目方法哦GOPATH指定目录下,可以再磁盘的任何位置新建一个项目,Go1.13以后可以彻底不要GOPATH了.

		go mod init初始化项目
			实际项目开发中首先要在项目中go mod命令生成一个go.mod文件管理项目的依赖.


	golang中自定义包
		包(package)是多个Go源码的集合,一个包可以简单理解为一个存放多个.go文件的文件夹.该文件夹下面的所有go文件
		都要在代码的第一行添加,声明该文件归属的包.

		注意事项:
			一个文件夹下面直接包含的文件只能归属一个package,同样一个package的文件不能再多个文件夹下.
			包名以不和文件夹名字一样,包名不能包含-符号.
			包名为main的包为应用程序的入口包,这一种包编译后会得到一个可以执行文件,而编译不包含main的源代码则不会得到可执行文件.

		定义一个包
			如果想在一个包中引用另外一个包里的标识符(如变量、常量、类型、函数等)时,该标识符必须是对外可见的(public).在Golang中只需要
			将标识符的首字母大写就可以让标识符对外可见了.

		包导入

		匿名导入包
			如果只是希望导入包,二不使用包内部的数据时,可以使用匿名导入包.具体的格式:
				import _ "包路径"

		自定义包名
			在导入包名的时候,还可以为包导入的包设置别名.通常用于导入的包名太长或者导入的包名冲突的情况:
				import 别名 "包的路径"

	Golang中init()初始化函数
		在Go语言程序执行导入包语句会自动触发包内部init()函数的调用.需要注意的是: 
			init() 函数没有参数也没有返回值.init()喊出在程序运行时自动被调用执行,不能在代码中主动调用它.

		init()函数执行顺序
			Go语言包会从main包开始检查其导入的所有包,每个包中又可能导入了其他的包.Go编译器由此构建出一个树状的包引用关系,
			再根据引用顺序决定编译顺序,依次编译这些包的代码.在运行时,被最后导入的包会最先优化并调用其init()函数.


	Golang中使用第三方包
		1、第三方包查找: https://pkg.go.dev/
		2、安装指定包
			方法一: go get github.com/shopspring/decimal
			方法二: go mod download		//依赖包会自动下载到$GOPATH/pkg/mod下
			方法三: go mod vendor		//将依赖复制到当前项目的vendor下



Golang中的接口(interface)
	Golang中的接口是一种抽象数据类型,Golang中接口定义了对象的行为规范,只定义规范不实现.接口中定义的规范由具体的对象来实现.
	在Golang中接口(interface)是一种类型,一种抽象的类型,接口(interface)是一组函数method的集合,Golang中的接口不能包含任何变量.
	在Golang中接口的所有方法都没有方法体,接口定义了一个对象的行为规范,只定义对方不实现.接口体现了程序设计的多态和高内聚低耦合的思想.
	Golang中的接口也是一种数据类型,不需要显示实现,只需要一个变量含有接口类型中的所有方法,那么这个变量就实现了这个接口.

	接口名: 使用type将接口定义为自定义类型名.Go语言的接口在命名时,一般会在单词后面添加er,如有写操作接口叫Writer,有字符串功能的接口
	       叫Stringer等,接口名最好要能突出该接口的类型含义.

	方法名: 	当方法名首字母是大写且这个接口类型名首字母也是大写时,这个方法可以被接口所在的包(package)之外的代码访问.
	参数列表、返回值列表: 参数列表和返回值列表中的参数变量名可以省略.

	空接口:
		Golang中的接口可以不定义任何方法,没有定义任何方法的接口就是空接口,空接口表示没有任何约束.因此任何类型变量都可以实现空接口
		空接口在实际项目中用的是非常多的,用空接口可以表示任意数据类型.
		使用空接口实现可以接收任意类型的函数参数.
		使用空接口实现可以保存任意值的字典.


		类型断言:
			一个接口的值(简称接口值)是由一个具体类型和具体类型的值两部分组成的.这两部分分别称为接口的动态类型和动态值.
			如果想要判断空接口中值的类型,那么这个时候可以使用类型断言.

		因为空接口可以存储任意值的热点,所以空接口在Go语言中的使用十分广泛.
		注意: 只有当两个或两个以上的具体类型必须以相同的方式进行处理是才需要定义接口.
		      不要为了接口而写接口,那样只会增加不必要的抽象,导致不必要的运行时损耗.



