

反射
	反射的引子
		有时需要些一个函数,这个函数有能力统一处理各种值类型.而这些类型可能无法共享同一个接口,
		也有可能这个类型在设计函数时还不存在,这个时候就可以用到反射.

			1.接口可以存储任意类型的变量,那如何知道这个空接口保存数据的类型是什么?值是什么呢?
				a、可以使用类型断言
				b、可以使用反射实现,也就是在程序运行时动态的获取一个变量的类型信息和值信息.
			2.把结构体序列化成json字符串,自定义结构体Tag标签的时候就用到了发射.

	反射的基本介绍
		1、反射是指在程序运行期间对程序本身进行访问和修改的能力.
		2、正常情况程序在编译时,变量被转换为内存地址,变量名不会被编译器写入到可以执行部分.
		3、在运行程序时,程序无法获取自身的信息.
		4、支持反射的语言可以在程序编译期将变量的反射信息,如字段名称、类型信息、结构体信息等整合到可执行文件中,
		   并给程序提供接口访问反射信息,这样就可以在程序运行期获取类型的反射信息,并且有能力修改它们.

		Golang中反射可以实现以下功能:
			1.反射可以在程序运行期间动态的获取变量的各种信息,比如变量的类型类别
			2.如果是结构体,通过反射还可以获取结构体本身的信息,比如结构体的字段、结构体的方法、结构体的tag.
			3.通过反射,可以修改变量的值,可以调用关联的方法.

		Go语言中的变量是分为两部分的:
			1.类型信息: 预先定义好的元信息
			2.值信息: 程序运行过程中可动态变化的.

		在Golang的发射机制中,任何接口值都是由一个具体类型和具体类型的值两部分组成的.
		在Golang中,反射的相关功能由内置的reflect包提供,任意接口值在反射中都可以理解为reflect.Type和reflect.Value两部分组成,
		并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个重要函数来获取任意对象的Value和Type.


	reflect.TypeOf()获取任意值的类型对象
		在Go语言中,使用reflect.TypeOf()函数可以接受任意interface{}参数,可以获得任意值的类型对象(reflect.Type),
		程序通过类型对象可以访问任意值的类型信息.

		type Name和type Kind
			在反射中关于类型还划分为两种:
				类型(Type)和种类(Kind).因为在Go语言中可以使用type关键字构造很多自定义类型,而种类(Kind)就是指底层的类型,但在反射中,
				当需要区分指针、结构体等大品种的类型时,就会用到这种类(Kind).例如: 定义了两个指针类型和两个结构体类型,通过反射查看它们
				的类型和种类.
			Go语言的反射中像数组、切片、Map、指针等类型的变量,它们的.Name()都是返回空.

		reflect包中定义的Kind类型
			参照"Golang反射 反射的引出、反射获取变量类型变量值、发射修改变量值"


	reflect.ValueOf()
		reflect.ValueOf()返回的是reflect.Value类型,其中包含了原始值的信息,reflect.Value与原始值之间可以互相转换.

		想要在函数中通过反射修改变量的值,需要注意函数参数传递的是值拷贝,必须传递边浪地址才能修改变量值,而反射中使用专有的Elem()方法来获取指针对应的值.



	结构体反射
		1.与结构体相关的方法
			任意值通过reflect.TypeOf()获得反射对象信息后,如果它的类型结构体,可以通过反射值对象(reflect.Type)的NumField()和Field()方法获得结构体成员的详细信息.

		2.StructField类型
			StructField类型用来描述结构体中的一个字段的信息.


	反射总结
		反射是一个强大并富有表现力的工具,能让写出更灵活的代码,但是反射不应该被滥用,原有以下两个:
			1.基于反射的代码时机器脆弱的,反射中的类型错误会在真正运行的时候才会引发panic,那很可能在代码写完的很长时间之后.
			2.大量使用反射的代码通常难以理解.



Golang文件、目录操作
	打开和关闭文件
		os.Open()函数能够打开一个文件,返回一个File和一个err.操作完成文件对象以后一定要记得关闭文件;
		为了防止文件忘记关闭,通常使用defer注册文件关闭语句.

	file.Read()读取文件

	循环读取
		使用for循环读取文件中的所有数据

	bufio读取文件
		bufio是在file的基础上封装了一层API,支持更多的功能.

	ioutil读取真个文件
		io/ioutil包的ReadFile方法能够读取完整的文件,值需要将文件名作为参数传入.

	文件写入操作
		os.OpenFile()函数能够以指定模式打开文件,从而实现文件写入相关功能.
			func OpenFile(name string,flag int,perm FileMode) (*File,error){
				...
			}

			name: 要打开文件名
			flag: 打开文件的模式
			perm: 文件权限,一个八进制数,r(读)04,w(写)02,x(执行)01.


		Write和WriteString

		bufio.NewWriter

		ioutil.WriterFile


	文件重命名
		os.Rename()

	复制文件
		io/ioutil
		复制文件流方式


	创建目录
		创建单个目录: os.Mkdir()
		创建多个目录: os.MkdirAll()

	删除目录和文件
		删除一个目录或者文件: os.Remve("")
		一次删除多个目录或者文件: so.RemoveAll("")


