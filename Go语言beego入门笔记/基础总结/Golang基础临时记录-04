

Golang goroutine channel实现并发和并行
	进程、线程以及并行、并发
		进程和线程
			进程(Process)就是程序在操作系统中的一次执行过程,是系统进行资源分配和调度的基本单位,进程是一个动态概念,
			是程序在执行过程中分配和管理资源的基本单位每一个进程都有一个自己的地址空间.

			一个进程至少有5种基本状态:	初始状态 ---> 执行状态 ---> 等待状态 ---> 就绪状态 ---> 终止状态
			通俗的理解进程就是一个在执行的程序;线程是进程的一个执行实例,是程序执行的最小单元,它是比进程更小的能独立运行的基本单位.

			一个进程可以创建多个线程,同一个进程中的多个线程可以并发执行,一个程序运行的话治至少有一个进程.


		并行和并发
			并发: 多个线程同时竞争一个位置,竞争到的才可以执行,每一个时间段只有一个线程在执行.
			并行: 多个线程可以同时执行,每一个时间段,可以有多个线程同时执行.

			通俗的讲多线程程序在单核CPU上面运行就是并发,多个线程程序在多核CPU上运行就是并行,如果是线程数大于CPU合数,
			则多线程程序在多个CPU上面运行既有并行又有并发.


	Golang中的协程(goroutine)以及主线程
		golang中的主线程: (可以理解为线程/也可以理解为进程),在一个Golang程序的主线程上可以起多个协程.Golang中多个协程可以实现并行或者并发.
		协程: 可以理解为用户级线程,这是对内核透明的,也就是系统并不知道有协程的存在,是完全由用户自己的程序进行调度的.
			  Golang的一个特色就是从语言层面原生支持协程,在函数或者方法前面添加go关键字就可以创建一个协程,可以说Golang中的协程就是goroutine.

		Golang中的多协程优点类似其他语言中的多线程.
		多协程和多线程: Golang中每个goroutine(协程)默认占用内存远比Java、C的线程少.
		OS线程(操作系统线程)一般都有固定的栈内存(通常为2MB左右),一个goroutine(协程)占用内存非常小,只有2KB左右,多协程goroutine切换调度开销方面远比线程要小.

	Goroutine的使用以及sync.WaitGroup
		并执行执行需求:
			在主线程(可以理解成进程)中,开启一个goroutine,该协程每个50毫秒输出"你好golang"
			在主线程中也每隔50毫秒输出"你好gloang",输出10次后,退出程序,要求主线程和goroutine同时执行.
		goroutine是并发执行的,而goroutine的调度是随机的.


	设置Golang并行运行的时候占用的CPU数量
		Go运行的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行Go代码.
		默认值是机器上的CPU核心数,例如在一个8核心的机器上,调度器会把Go代码同时调度到8个OS线程上.
		Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数.
		Go1.5版本之前,默认使用的是单核心执行,Go1.5版本之后,默认使用全部的CPU逻辑核心数.

	Channel管道
		管道是Golang在语言级别上提供的goroutine间的通讯方式,可以使用channel在多个goroutine之间传递消息,如果说goroutine是Go程序并发的执行体,
		channel就是它们之间的链接,channel是可以一个goroutine发送特定值到另一个goroutine的通信机制.

		Golang的并发模型是CSP(Communicating Sequential Processes),提倡通过通信共享内存而不是通过共享内存而实现通信.

		Go语言中的管道(channel)是一种特殊的类型.管道像一个传送带或者队列,总是遵循先入先出(First In First Out)的规则,保证收发数据的顺序.
		每一个管道都是一个具体类型的导管,也就是声明channel的时候需要为其指定元素类型.


		channel类型
			channel是一种类型,一种引用类型.
		创建channel
			声明的管道需要使用make函数初始化之后才能使用.


		channel操作
			管道有发送(send)、接收(receive)和关闭(close)三种操作.
			发送和接收都是用<-符号.

			关闭后的管道有以下特点:
				1.对一个关闭的管道再发送值就会导致panic
				2.对一个关闭的管道进行接收会一直获取值直到管道为空
				3.对一个关闭的并且没有值的管道执行接收操作会得到对应类型的零值.
				4.关闭一个已经关闭的管道会导致panic

		管道阻塞:
			1.无缓冲的管道
				如果创建管道的时候没有指定容量,那么可以叫这个管道为无缓冲管道;无缓冲的管道又称为阻塞的管道.
			2.有缓冲的管道
				使用有缓冲区的管道,可以再使用make初始化管道的时候为其指定管道的内容.
				只要管道的容量大于零,那么该管道就是有缓冲的管道,管道的容量表示管道中能存放元素的数量.
				就像小区的快递柜只有那么多个格子,格式满了就装不下了,就阻塞了,等到别人取走一个,快递员就能往里面放一个.

		for range从管道循环取值
			当向管道中发送完数据时,可以通过close函数来关闭管道.
			当管道被关闭是,再往该管道发送值会引发panic,从该管道取值的操作会先取完管道中的值,再然后取到的值一直都是对应类型的零值.
			如何判断一个管道是否被关闭了?


	Goroutine结合Channel管道


	单向管道
		有的时候会将管道作为参数在多个任务函数间传递,很多时候在不同的任务函数中使用管道都会对其进行限制.比如限制管道再函数中只能发送或只能接收.
		默认情况下管道是,双向的;只有特殊声明管道为单向
			声明只写管道:
				var chan_name chan<- type
			声明只读管道:
				var chan_name <-chan type

	select多路复用
		传统的方法在遍历管道时,如果不关闭会阻塞而导致deadlock,在实际开发中,可能不要确定什么关闭管道.
		Go内置了select关键字,可以同时响应多个管道的操作.
		select的使用类似于switch语句,它有一系列case分支和一个默认的分支.每个case会对应一个管道的通信(接收或发送)过程.
		select会一直等待,知道某个case的通信操作完成时,就会执行case分支对应语句.

		使用select语句能提高代码的可读性:
			.处理一个或多个channel的发送/接收操作.
			.如果多个case同时满足,select会随机选择一个.
			.对于没有case的select{}会一直等待,可用于阻塞main函数.


	Golang并发安全和锁
		1.互斥锁
			互斥锁是一种常用的控制共享资源访问的方法,它能够保证同时只有一个goroutine可以访问共享资源.
			Go语言中使用sync包的Mutex类型来实现互斥锁.
			使用互斥锁能够保证同一时间有且只有一个goroutine进入临界区.其他的goroutine则在等待锁;
			当互斥锁释放后,等待的goroutine才可以获取进入临界区,多个goroutine同时等待一个锁时,唤醒的策略是随机的.
			虽然使用互斥锁能解决资源争夺文件,但是并不完美,通过全局变量枷锁同步来事项通讯.
			并不利于多个协程对全局变量的读写操作.这个时候也可以通过另一种方式来实现.

		2.读写互斥锁
			互斥锁是完全互斥的,但是有很多实际的场景下是读多邪少的,当并发的去读取一个资源不涉及资源修改的时候是没有必要枷锁的,
			这种场景下使用读写互斥锁是更好的一种选择.读写锁在Go语言中使用sync包中的RWMutex类型.
			读写锁分为两种: 读锁和写锁.当一个goroutine获取读锁之后,其他的goroutine如果是获取读锁会继续获得锁,如果是获取写锁就会等待;
			              当一个goroutine获取写锁之后,其他的goroutine无论是获取读锁还是写锁都会等待.

			注意: 读写锁非常适合读多写少的场景,如果读和谐的操作差别不大,读写锁的优势就发挥不出来.


	Goroutine Recover解决协程中出现的Panic


